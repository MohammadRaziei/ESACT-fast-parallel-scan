<!DOCTYPE html>
<html lang="en">

<head>
    <title>Prefix Sum Algorithm</title>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Include Tailwind CSS -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <!-- Include Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <!-- Add custom styles for GitHub repository page -->
    <style>
        html,
        body {
            height: 100%;
        }

        .github-logo {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10;
        }
    </style>
</head>

<body class="bg-gray-100">
    <div class="container">
        <div class="f">
            <a href="https://github.com/MohammadRaziei/ESACT-fast-parallel-scan" target="_blank"
                rel="noopener noreferrer" class="github-logo">
                <div class="inline flex-col relative">
                    <i class="fab fa-github fa-2x flex"></i>
                    <span class="">
                        Github Repo
                    </span>
                </div>
                <img class="flex"
                    src="https://img.shields.io/github/stars/mohammadraziei/ESACT-fast-parallel-scan?style=social" />
            </a>
        </div>
        <div class="container my-4">
            <div class="p-4">

                <h3 class="text-2xl font-bold mb-4 mt-10">Prefix Sum Algorithm's Graph</h3>
                <p class="mb-4">Please input the power of two.</p>


                <div class="flex-inline">
                    <label for="selectAlgorithms">Choose a Algorithm:</label>
                    <select name="selectAlgorithms" id="selectAlgorithms"
                        class="border border-gray-300 px-4 py-2 rounded-lg mb-4">
                        <option value="blelloch">Blelloch</option>
                        <option value="esact" selected="selected">ESACT</option>
                    </select>
                </div>


                <div class="flex-inline">
                    <label for="inputNumberOfNodes">Choose a Algorithm:</label>
                    <input id="inputNumberOfNodes" value="8" type="number"
                        class="border border-gray-300 px-4 py-2 rounded-lg mb-4">
                </div>



                <div class="w-full my-5 overflow-hidden">
                    <div class="m-0">
                        <svg id="canvas"></svg>
                    </div>
                </div>

                <button
                    class="border border-gray-300 px-4 py-2 rounded-lg mb-4 bg-gray-100 bg-blue-500 hover:bg-blue-700 text-white font-bold"
                    onclick="onSaveBtn()">
                    save
                </button>



            </div>
        </div>
    </div>

    <script>
        // window.addEventListener('DOMContentLoaded', () => {
        const input = document.getElementById('inputNumberOfNodes');

        // Your D3.js code to fill the SVG goes here



        var svgD3 = d3.select("svg#canvas").attr("preserveAspectRatio", "xMinYMin meet");

        const svgElem = document.getElementById('canvas');

        // https://www.w3.org/TR/SVG11/types.html#ColorKeywords



        function Text(x, y, text) {
            this.x = x;
            this.y = y;
            this.text = text;


            if (this.text !== "") {
                this.elem = svgD3.append("text")
                    .attr("x", this.x)
                    .attr("y", this.y)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "central")
                    .text(this.text);
            }

            // Return a reference to the rectangle for future use
            return this;



        }


        // Node component representing a rectangle
        class Node {
            static width = 100;
            static height = 50;

            constructor(x, y, colorfill = "powderblue", text = "") {
                this.x = x;
                this.y = y;
                this.colorfill = colorfill;
                this.width = Node.width;
                this.height = Node.height;
                this.text = text;
            }

            draw() {
                this.elem = svgD3.append("rect")
                    .attr("x", this.x)
                    .attr("y", this.y)
                    .attr("width", this.width)
                    .attr("height", this.height)
                    .attr("stroke", "black")
                    .attr("fill", this.colorfill);

                this.addText(this.text);

                // Return self for method chaining
                return this;
            }

            addText(text) {
                Text(this.x + this.width / 2, this.y + this.height / 2, text);
            }


            getBottomCenter() {
                return { x: this.x + this.width / 2, y: this.y + this.height };
            }

            getTopCenter() {
                return { x: this.x + this.width / 2, y: this.y };
            }
        }

        // Arrow component to draw an arrow between two nodes
        class Arrow {
            constructor(fromNode, toNode, color = "black") {


                this.draw = function () {
                    var start = fromNode.getBottomCenter();
                    var end = toNode.getTopCenter();

                    const calcX = (n1, n2) => {
                        const tmp = .95 * n1.x + .05 * n2.x;
                        return Math.max(Math.min(tmp, n1.x + Node.width * .3), n1.x - Node.width * .3);
                    };
                    svgD3.append("line")
                        .attr("x1", calcX(start, end))
                        .attr("y1", start.y)
                        .attr("x2", calcX(end, start))
                        .attr("y2", end.y - 1)
                        .attr("stroke", color)
                        .attr("stroke-width", 2)
                        .attr("marker-end", "url(#arrow)");
                }
            }
        }


        function createIndices(n) {
            let omega = [];
            omega[0] = n - 1;

            for (let i = 0; 2 * i + 1 < n; i++) {
                omega[2 * i] = Math.floor((omega[i] + omega[0]) / 2);
                omega[2 * i + 1] = Math.floor(omega[i] / 2);
            }

            return omega;
        }



        function create_svg(number_nodes) {

            svgD3.selectAll("*").remove();
            // Create the arrow marker definition
            svgD3.append("svg:defs").append("svg:marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 8) // Adjust the refX to offset the arrow to align properly
                .attr("refY", 0)
                .attr("markerWidth", 4)
                .attr("markerHeight", 4)
                .attr("orient", "auto")
                .append("svg:path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "black");

            const selectAlg = document.getElementById("selectAlgorithms");



            const number_of_steps = Math.floor(Math.log2(number_nodes) + 1) * 2




            // Create two instances of the Node component

            var nodes = Array.from({ length: number_of_steps }, (_, col) =>
                Array.from({ length: number_nodes }, (_, row) =>
                    new Node(row * (Node.width), (col + 1) * (Node.height * 2)).draw()
                )
            );

            var input_nodes = Array.from({ length: number_nodes }, (_, i) =>
                new Node(i * (Node.width), 0, "aquamarine", `X_${i}`).draw()
            );

            var output_nodes = Array.from({ length: number_nodes }, (_, i) =>
                new Node(i * (Node.width), (number_of_steps + 1) * (Node.height * 2), "aquamarine", `Y_${i}`).draw()
            );

            const totalwidth = (Node.width) * number_nodes+2;
            const totalheight = (Node.height * 2) * (number_of_steps + 2) - Node.height + 2;


            svgElem.setAttribute("width", totalwidth + 'px');
            svgElem.setAttribute("height", totalheight + 'px');

            // svgD3.style("width", totalwidth + 'px').style("height", totalheight + 'px');








            // JavaScript code to scale the SVG if width is larger
            const svgMaxWidth = svgElem.parentElement.clientWidth;
            const svgClientWidth = svgElem.clientWidth
            const scaleRatio = svgMaxWidth / svgClientWidth;
            if (scaleRatio < 1) {
                svgD3.style("transform", `scale(${scaleRatio})`);
                svgD3.style("transform-origin", "top left");
                svgElem.parentElement.style.height = `${totalheight * scaleRatio}px`;
                svgElem.parentElement.style.width = `${totalwidth * scaleRatio}px`;
            }





            switch (selectAlg.value) {
                case "blelloch":

                    {
                        for (let i = 0; i < number_nodes; i++) {
                            new Arrow(input_nodes[i], nodes[0][i], "darkcyan").draw();
                        }

                        let row = 0
                        for (let s = 2; s <= number_nodes; s <<= 1) {
                            for (let i = 0; i < number_nodes / s; i++) {
                                new Arrow(nodes[row][s * i + Math.floor(s / 2) - 1], nodes[row + 1][s * i + s - 1]).draw();
                                new Arrow(nodes[row][s * i + s - 1], nodes[row + 1][s * i + s - 1]).draw();
                            }
                            row++;
                        }
                        const sum_node = nodes[row++][number_nodes - 1];
                        new Arrow(sum_node, nodes[row][number_nodes - 1], "red").draw();
                        sum_node.elem.attr("fill", "lightcyan");
                        sum_node.addText("Sum");
                        nodes[row][number_nodes - 1].addText("0");


                        for (let s = number_nodes; s > 1; s >>= 1) {
                            for (let i = 0; i < number_nodes / s; i++) {
                                new Arrow(nodes[row][s * i + Math.floor(s / 2) - 1], nodes[row + 1][s * i + s - 1]).draw();
                                new Arrow(nodes[row][s * i + s - 1], nodes[row + 1][s * i + s - 1]).draw();
                                new Arrow(nodes[row][s * i + s - 1], nodes[row + 1][s * i + Math.floor(s / 2) - 1], "mediumvioletred").draw();
                            }
                            row++;
                        }

                        for (let i = 0; i < number_nodes; i++) {
                            new Arrow(nodes[number_nodes - 1][i], output_nodes[i], "darkcyan").draw();
                        }

                    }
                    // code block
                    break;
                case "esact":
                    {

                        const indices = createIndices(number_nodes);
                        for (let i = 0; i < number_nodes; i++) {
                            new Arrow(input_nodes[i], nodes[0][indices[i]], "darkcyan").draw();
                        }

                        let row = 0
                        for (let s = number_nodes >> 1; s > 0; s >>= 1) {
                            for (let i = 0; i < s; i++) {
                                new Arrow(nodes[row][i + s], nodes[row + 1][i]).draw();
                                new Arrow(nodes[row][i], nodes[row + 1][i]).draw();
                            }
                            row++;
                        }
                        const sum_node = nodes[row++][0];
                        new Arrow(sum_node, nodes[row][0], "red").draw();
                        sum_node.elem.attr("fill", "lightcyan");
                        sum_node.addText("Sum");
                        nodes[row][0].addText("0");




                        for (let s = 1; s < number_nodes; s <<= 1) {
                            for (let i = 0; i < s; i++) {
                                new Arrow(nodes[row][i + s], nodes[row + 1][i]).draw();
                                new Arrow(nodes[row][i], nodes[row + 1][i]).draw();
                                new Arrow(nodes[row][i], nodes[row + 1][i + s], "mediumvioletred").draw();
                            }
                            row++;
                        }

                        for (let i = 0; i < number_nodes; i++) {
                            new Arrow(nodes[row][indices[i]], output_nodes[i], "darkcyan").draw();
                        }
                    } break;
                default:
                    console.log("error");
            }
        }

        input.addEventListener("keypress", function (event) {
            if (event.key === "Enter") {
                event.preventDefault();
                create_svg(parseInt(input.value));
            }
        });
        create_svg(parseInt(input.value));



        // var isTouchDevice = function () { return 'ontouchstart' in window || 'onmsgesturechange' in window; };
        // var isDesktop = window.screenX != 0 && !isTouchDevice() ? true : false;

        // console.log(isDesktop?"Desktop Mode": "Mobile Mode")
        // if (isDesktop) {
        addEventListener("resize", () => {
            create_svg(parseInt(input.value));
        });
        // }



        function saveSvg(svgEl, name) {
            svgEl.style.transform = null;
            svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            var svgData = svgEl.outerHTML;
            var preface = '<?xml version="1.0" standalone="no"?>\r\n';
            var svgBlob = new Blob([preface, svgData], { type: "image/svg+xml;charset=utf-8" });
            var svgUrl = URL.createObjectURL(svgBlob);
            var downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = name;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }

        function onSaveBtn() {
            saveSvg(svgElem.cloneNode(true), 'graph.svg');
        }




        // });
    </script>
</body>

</html>